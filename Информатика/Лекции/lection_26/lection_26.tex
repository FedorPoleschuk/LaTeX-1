\documentclass[a4paper,12pt]{article}

%%% Работа с русским языком % для pdfLatex
\usepackage{cmap}					% поиск в~PDF
\usepackage{mathtext} 				% русские буквы в~фомулах
\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы
\usepackage{indentfirst} 			% отступ 1 абзаца

%%% Работа с русским языком % для XeLatex
%\usepackage[english,russian]{babel}   %% загружает пакет многоязыковой вёрстки
%\usepackage{fontspec}      %% подготавливает загрузку шрифтов Open Type, True Type и др.
%\defaultfontfeatures{Ligatures={TeX},Renderer=Basic}  %% свойства шрифтов по умолчанию
%\setmainfont[Ligatures={TeX,Historic}]{Times New Roman} %% задаёт основной шрифт документа
%\setsansfont{Comic Sans MS}                    %% задаёт шрифт без засечек
%\setmonofont{Courier New}
%\usepackage{indentfirst}
%\frenchspacing

%%% Дополнительная работа с математикой
\usepackage{amsfonts,amssymb,amsthm,mathtools}
\usepackage{amsmath}
\usepackage{icomma} % "Умная" запятая: $0,2$ --- число, $0, 2$ --- перечисление
\usepackage{upgreek}

%% Номера формул
%\mathtoolsset{showonlyrefs=true} % Показывать номера только у тех формул, на которые есть \eqref{} в~тексте.

%%% Страница
\usepackage{extsizes} % Возможность сделать 14-й шрифт

%% Шрифты
\usepackage{euscript}	 % Шрифт Евклид
\usepackage{mathrsfs} % Красивый матшрифт

%% Свои команды
\DeclareMathOperator{\sgn}{\mathop{sgn}} % создание новой конанды \sgn (типо как \sin)
\usepackage{csquotes} % ещё одна штука для цитат
\newcommand{\pd}[2]{\ensuremath{\cfrac{\partial #1}{\partial #2}}} % частная производная
\newcommand{\abs}[1]{\ensuremath{\left|#1\right|}} % модуль
\renewcommand{\phi}{\ensuremath{\varphi}} % греческая фи
\newcommand{\pogk}[1]{\!\left(\cfrac{\sigma_{#1}}{#1}\right)^{\!\!\!2}\!} % для погрешностей

% Ссылки
\usepackage{color} % подключить пакет color
% выбрать цвета
\definecolor{BlueGreen}{RGB}{49,152,255}
\definecolor{Violet}{RGB}{120,80,120}
% назначить цвета при подключении hyperref
\usepackage[unicode, colorlinks, urlcolor=blue, linkcolor=blue, pagecolor=blue, citecolor=blue]{hyperref} %синие ссылки
%\usepackage[unicode, colorlinks, urlcolor=black, linkcolor=black, pagecolor=black, citecolor=black]{hyperref} % для печати (отключить верхний!)


%% Перенос знаков в~формулах (по Львовскому)
\newcommand*{\hm}[1]{#1\nobreak\discretionary{}
	{\hbox{$\mathsurround=0pt #1$}}{}}

%%% Работа с картинками
\usepackage{graphicx}  % Для вставки рисунков
\graphicspath{{images/}{images2/}}  % папки с картинками
\setlength\fboxsep{3pt} % Отступ рамки \fbox{} от рисунка
\setlength\fboxrule{1pt} % Толщина линий рамки \fbox{}
\usepackage{wrapfig} % Обтекание рисунков и таблиц текстом
\usepackage{multicol}

%%% Работа с таблицами
\usepackage{array,tabularx,tabulary,booktabs} % Дополнительная работа с таблицами
\usepackage{longtable}  % Длинные таблицы
\usepackage{multirow} % Слияние строк в~таблице
\usepackage{caption}
\captionsetup{labelsep=period, labelfont=bf}

%%% Оформление
\usepackage{indentfirst} % Красная строка
%\setlength{\parskip}{0.3cm} % отступы между абзацами
%%% Название разделов
\usepackage{titlesec}
\titlelabel{\thetitle.\quad}
\renewcommand{\figurename}{\textbf{Рис.}}		%Чтобы вместо figure под рисунками писал "рис"
\renewcommand{\tablename}{\textbf{Таблица}}		%Чтобы вместо table над таблицами писал Таблица

%%% Теоремы
\theoremstyle{plain} % Это стиль по умолчанию, его можно не переопределять.
\newtheorem{theorem}{Теорема}[section]
\newtheorem{proposition}[theorem]{Утверждение}

\theoremstyle{definition} % "Определение"
\newtheorem{definition}{Определение}[section]
\newtheorem{corollary}{Следствие}[theorem]
\newtheorem{problem}{Задача}[section]

\theoremstyle{remark} % "Примечание"
\newtheorem*{nonum}{Решение}
\newtheorem{zamech}{Замечание}[theorem]

%%% Правильные мат. символы для русского языка
\renewcommand{\epsilon}{\ensuremath{\varepsilon}}
\renewcommand{\phi}{\ensuremath{\varphi}}
\renewcommand{\kappa}{\ensuremath{\varkappa}}
\renewcommand{\le}{\ensuremath{\leqslant}}
\renewcommand{\leq}{\ensuremath{\leqslant}}
\renewcommand{\ge}{\ensuremath{\geqslant}}
\renewcommand{\geq}{\ensuremath{\geqslant}}
\renewcommand{\emptyset}{\varnothing}

%%% Для лекций по инфе
\usepackage{tikz}  
\usetikzlibrary{graphs}
\usepackage{alltt}
\newcounter{infa}[section]
\newcounter{num}
\definecolor{infa}{rgb}{0, 0.2, 0.89}
\definecolor{infa1}{rgb}{0, 0.3, 1}
\definecolor{grey}{rgb}{0.5, 0.5, 0.5}
\newcommand{\tab}{\ \ \ }
\newcommand{\com}[1]{{\color{grey}\# #1}}
\newcommand{\num}{\addtocounter{num}{1}\arabic{num}\tab}
\newcommand{\defi}{{\color{infa}def}}
\newcommand{\globali}{{\color{infa}global}}
\newcommand{\ini}{{\color{infa}in}}
\newcommand{\rangei}{{\color{infa}range}}
\newcommand{\fori}{{\color{infa}for}}
\newcommand{\ifi}{{\color{infa}if}}
\newcommand{\elsei}{{\color{infa}else}}
\newcommand{\printi}{{\color{infa1}print}}
\newcommand{\enumeratei}{{\color{infa1}enumerate}}
\newcommand{\maxi}{{\color{infa}max}}
\newcommand{\classi}{{\color{infa}class}}
\newcommand{\returni}{{\color{infa}return}}
\newcommand{\elifi}{{\color{infa}elif}}
\newcommand{\seti}{{\color{infa}set}}
\newcommand{\noti}{{\color{infa}not}}
\newcommand{\dicti}{{\color{infa}dict}}
\newcommand{\zipi}{{\color{infa}zip}}
\newcommand{\chri}{{\color{infa}chr}}
\newcommand{\ordi}{{\color{infa}ord}}
\newcommand{\leni}{{\color{infa}len}}
\newcommand{\deli}{{\color{infa}del}}
\newcommand{\sortedi}{{\color{infa}sorted}}
\newcommand{\keyi}{{\color{infa}key}}
\newcommand{\lambdai}{{\color{infa}lambda}}
\newcommand{\inti}{{\color{infa}int}}
\newcommand{\inputi}{{\color{infa}input}}
\newcommand{\isi}{{\color{infa}is}}
\newcommand{\Nonei}{{\color{infa}None}}
\newcommand{\whilei}{{\color{infa}while}}
\newcommand{\andi}{{\color{infa}and}}
\newcommand{\fromi}{{\color{infa}from}}
\newcommand{\importi}{{\color{infa}import}}
\newcommand{\continuei}{{\color{infa}continue}}
\newcommand{\mapi}{{\color{infa}map}}
\newcommand{\Falsei}{{\color{infa1}False}}
\newcommand{\listi}{{\color{infa}list}}
\newcommand{\Truei}{{\color{infa1}True}}
\newcommand{\mini}{{\color{infa1}min}}
\newcommand{\breaki}{{\color{infa1}break}}


\newenvironment{infa}[1]{
	
	\vspace{0.5cm}
	\addtocounter{infa}{1}%
	\noindent{\large \textbf{Программа №\thesection.\arabic{infa}.}\ \textbf{#1}}%
	\begin{alltt}%
	}{\end{alltt}
	\setcounter{num}{0}
	\vspace{0.1cm}}
\newenvironment{infanoname}{
	
	%\vspace{0.5cm}
	%\addtocounter{infa}{1}%
	%\noindent{\large \textbf{Программа №\thesection.\arabic{infa}.}\ \textbf{#1}}%
	\begin{alltt}%
	}{\end{alltt}
	\setcounter{num}{0}
	\vspace{0.1cm}}

\usepackage{animate} % Для добавления гифок
\usepackage{xmpmulti}
%Пример кода:
%\begin{infa}{Поразрядная сортировка}
%	\ \num \defi count_sort(a):\tab \com{определяет нашу функцию}
%	\ \num \tab m = \maxi(a)+1
%	\ \num \tab q = [0]*m
%	\ \num \tab \fori x \ini a:
%	\ \num \tab \tab q[x] += 1
%	\ \num \tab pos = 0
%	\ \num \tab \fori x \ini q:
%	\ \num \tab \tab \fori i \ini \rangei(q[x]):
%	\ \num \tab \tab \tab a[pos] = x
%	\num \tab \tab \tab pos += 1
%\end{infa}

\usepackage[left=1.27cm,right=1.27cm,top=1.27cm,bottom=2cm]{geometry}
%\hbox to\textwidth{команда колонтитула}

\usepackage{verbatim}
\begin{document}
\newcounter{lec}
\newcommand{\lec}[1]{\addtocounter{lec}{1} \setcounter{section}{0}%
\begin{center}
{\LARGE ЛЕКЦИЯ \arabic{lec}%
\vspace{2mm}%

\textbf{#1}%
}
\end{center}
}
\newpage
\
\setcounter{lec}{25}
\lec{Z и префикс функция строки}
\section{Z--функция строки}
Z--функция строки --- функция от номера символа.
Z--функция --- это массив длинны \texttt{len(S) = N}, \texttt{z[i]} --- длина совпадающего префикса у строки \texttt{S} и \texttt{S[i:]}.

\texttt{z[0]} не определено. Но мы будем считать, что \texttt{z[0] = 0}. 

\begin{center}
"a a a a a"\\
z=[0, 4, 3, 2, 1]\\

"a b a c a b a"\\
z=[0, 0, 1, 0, 3, 0]
\end{center}

Зачем нужна z--функция?
Будем искать строчку \texttt{p=aba} и все ее вхождения в строке \texttt{abacabadabacaba}. Склеим две строки символом, которого точно нет ни там ни там:
\begin{center}
	\texttt{s = "aba\#abacabadabacaba"}.
\end{center}
Т.к. стоит символ \#, длина искомой подстроки не может быть больше 3.
$$
z = [0, 0, 1, 0, 3, 0, 1, 0, 3, 0, 1, 0, 3, 0, 1, 0, 3, 0, 1]
$$
Там, где \texttt{z[i] == len(p)}, т.е. там, где величина Z--функции равна длине подстроки, у нас есть совпадение, т.е. там подстрока содержится в строке. Позиция вхождения: найдена подстрока в строке, \texttt{pos = i-len(p)-1} --- номер вхождения.

Тривиальное вычисление Z--функции (требует $O(N^2)$).
\begin{infa}{Тривиальное вычисление Z--функции}
\num N = \leni(s)
\num z=[0]
\num left = right = 0
\num \fori i \ini \rangei(1, N):
\num \tab x = 0
\num \tab \whilei i + x < N \andi s[x] == s[i+x]:
\num \tab \tab x += 1
\num \tab z[i] = x
\num \tab if i + x - 1> right: \com{Сохраянем z--блок}
\num \tab \tab left, right = i, i + x - 1
\end{infa}
z--блок --- срез строки \texttt{s[i:i+z[i]]}, т.е. это часть строки, совпавшая с подстрокой.

На момент вычисления \texttt{z[i]} существует самый правый отрезок совпадения. Длина этого отрезка равна разнице его правого и левого конца + 1.

\begin{infa}{}
	\ \num N = \leni(s)
	\ \num z=[0]
	\ \num left = right = 0
	\ \num \fori i \ini \rangei(1, N):
	\ \num \tab x = \mini(z[i-left], right - i + 1) \ifi i<=right \elsei 0
	\ \num \tab \whilei i + x < N \andi s[x] == s[i+x]:
	\ \num \tab \tab x += 1
	\ \num \tab z[i] = x
	\ \num \tab \ifi i + x - 1> right: \com{Сохраянем z--блок}
	\num \tab \tab left, right = i, i + x - 1
\end{infa}
Этот алгоритм работает за линейное время.
\section{Префикс--функция строки. Алгоритм Кнута — Морриса — Пратта.}
\subsection{Префикс--функция строки}
Собственным суффиксом строки называется суффикс, не совпадающий со всей строкой, совпадающий с ее префиксом. 

Префикс--функция строки \texttt{$\pi$[i]} --- массив длинной строки, где \texttt{$\pi$[i]} --- длина наибольшего по длине собственного суффикса подстроки (среза) \texttt{s} начиная от начала и до позиции \texttt{i (s[:i+1])}.
\begin{center}
"a a a a a"\\
pi=[0, 1, 2, 3, 4]\\
"a b a c a b a"\\
pi = [0, 0, 1, 0, 1, 2, 3]\\
\end{center}
Заметим, что эта функция всегда растет на единицу.
\begin{infa}{Тривиальный алгоритм}
\num N = \leni(s)
\num pi = [0]*N
\num \fori i \ini \rangei(1, N):
\num \tab \fori k \ini \rangei(i+1):
\num \tab \tab \ifi s[0:k] == s[i-k+1:i+1]:
\num \tab \tab \tab pi[i] = k
\end{infa}
Асимптотика $O(N^3)$.

\begin{infa}{Эффективный алгоритм}
\num \defi prefix(s):
\num \tab n = \leni(s)
\num \tab pi = [0]*n
\num \tab \fori i \ini \rangei(1, n):
\num \tab \tab j = pi[i-1]
\num \tab \tab \whilei j > 0 \andi s[i] != s[j]:
\num \tab \tab \tab j = pi[j-1]
\num \tab \tab \ifi s[i] == s[j]:
\num \tab \tab \tab j += 1
\num \tab \tab pi[i] = j
\num \tab \returni pi
\end{infa}

\subsection{Алгоритм Кнута — Морриса — Пратта.}
Эта задача является классическим применением префикс-функции (и, собственно, она и была открыта в связи с этим).

Дан текст t и строка s, требуется найти и вывести позиции всех вхождений строки s в текст t.

Обозначим для удобства через n длину строки s, а через m — длину текста t.

Образуем строку s + \# + t, где символ \# — это разделитель, который не должен нигде более встречаться. Посчитаем для этой строки префикс-функцию. Теперь рассмотрим её значения, кроме первых n+1 (которые, как видно, относятся к строке s и разделителю). По определению, значение $\pi$[i] показывает наидлиннейшую длину подстроки, оканчивающейся в позиции i и совпадающего с префиксом. Но в нашем случае это $\pi$[i] — фактически длина наибольшего блока совпадения со строкой s и оканчивающегося в позиции i. Больше, чем n, эта длина быть не может — за счёт разделителя. А вот равенство $\pi$[i] = n (там, где оно достигается), означает, что в позиции i оканчивается искомое вхождение строки s (только не надо забывать, что все позиции отсчитываются в склеенной строке s+\#+t).

Таким образом, если в какой-то позиции i оказалось $\pi$[i] = n, то в позиции i - (n + 1) - n + 1 = i - 2 n строки t начинается очередное вхождение строки s в строку t.

Как уже упоминалось при описании алгоритма вычисления префикс-функции, если известно, что значения префикс-функции не будут превышать некоторой величины, то достаточно хранить не всю строку и префикс-функцию, а только её начало. В нашем случае это означает, что нужно хранить в памяти лишь строку s + \# и значение префикс-функции на ней, а потом уже считывать по одному символу строку t и пересчитывать текущее значение префикс-функции.

Итак, алгоритм Кнута-Морриса-Пратта решает эту задачу за O(n+m) времени и O(n) памяти.

Подробнее материал лекции изложен на \href{http://e-maxx.ru/algo/prefix_function}{сайте}.




\begin{center}
	\vfill \emph{{\small Г. С. Демьянов, \href{https://vk.com/id37346992}{VK}\\
С. С. Клявинек, \href{https://vk.com/id85132547}{VK}\\
А. С. Кожарин, \href{https://vk.com/id92540660}{VK}
}}
\end{center}





\end{document} 