\documentclass[a4paper,12pt]{article}

%%% Работа с русским языком % для pdfLatex
\usepackage{cmap}					% поиск в~PDF
\usepackage{mathtext} 				% русские буквы в~фомулах
\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы
\usepackage{indentfirst} 			% отступ 1 абзаца

%%% Работа с русским языком % для XeLatex
%\usepackage[english,russian]{babel}   %% загружает пакет многоязыковой вёрстки
%\usepackage{fontspec}      %% подготавливает загрузку шрифтов Open Type, True Type и др.
%\defaultfontfeatures{Ligatures={TeX},Renderer=Basic}  %% свойства шрифтов по умолчанию
%\setmainfont[Ligatures={TeX,Historic}]{Times New Roman} %% задаёт основной шрифт документа
%\setsansfont{Comic Sans MS}                    %% задаёт шрифт без засечек
%\setmonofont{Courier New}
%\usepackage{indentfirst}
%\frenchspacing

%%% Дополнительная работа с математикой
\usepackage{amsfonts,amssymb,amsthm,mathtools}
\usepackage{amsmath}
\usepackage{icomma} % "Умная" запятая: $0,2$ --- число, $0, 2$ --- перечисление
\usepackage{upgreek}

%% Номера формул
%\mathtoolsset{showonlyrefs=true} % Показывать номера только у тех формул, на которые есть \eqref{} в~тексте.

%%% Страница
\usepackage{extsizes} % Возможность сделать 14-й шрифт

%% Шрифты
\usepackage{euscript}	 % Шрифт Евклид
\usepackage{mathrsfs} % Красивый матшрифт

%% Свои команды
\DeclareMathOperator{\sgn}{\mathop{sgn}} % создание новой конанды \sgn (типо как \sin)
\usepackage{csquotes} % ещё одна штука для цитат
\newcommand{\pd}[2]{\ensuremath{\cfrac{\partial #1}{\partial #2}}} % частная производная
\newcommand{\abs}[1]{\ensuremath{\left|#1\right|}} % модуль
\renewcommand{\phi}{\ensuremath{\varphi}} % греческая фи
\newcommand{\pogk}[1]{\!\left(\cfrac{\sigma_{#1}}{#1}\right)^{\!\!\!2}\!} % для погрешностей

% Ссылки
\usepackage{color} % подключить пакет color
% выбрать цвета
\definecolor{BlueGreen}{RGB}{49,152,255}
\definecolor{Violet}{RGB}{120,80,120}
% назначить цвета при подключении hyperref
\usepackage[unicode, colorlinks, urlcolor=blue, linkcolor=blue, pagecolor=blue, citecolor=blue]{hyperref} %синие ссылки
%\usepackage[unicode, colorlinks, urlcolor=black, linkcolor=black, pagecolor=black, citecolor=black]{hyperref} % для печати (отключить верхний!)


%% Перенос знаков в~формулах (по Львовскому)
\newcommand*{\hm}[1]{#1\nobreak\discretionary{}
	{\hbox{$\mathsurround=0pt #1$}}{}}

%%% Работа с картинками
\usepackage{graphicx}  % Для вставки рисунков
\graphicspath{{images/}{images2/}}  % папки с картинками
\setlength\fboxsep{3pt} % Отступ рамки \fbox{} от рисунка
\setlength\fboxrule{1pt} % Толщина линий рамки \fbox{}
\usepackage{wrapfig} % Обтекание рисунков и таблиц текстом
\usepackage{multicol}

%%% Работа с таблицами
\usepackage{array,tabularx,tabulary,booktabs} % Дополнительная работа с таблицами
\usepackage{longtable}  % Длинные таблицы
\usepackage{multirow} % Слияние строк в~таблице
\usepackage{caption}
\captionsetup{labelsep=period, labelfont=bf}

%%% Оформление
\usepackage{indentfirst} % Красная строка
%\setlength{\parskip}{0.3cm} % отступы между абзацами
%%% Название разделов
\usepackage{titlesec}
\titlelabel{\thetitle.\quad}
\renewcommand{\figurename}{\textbf{Рис.}}		%Чтобы вместо figure под рисунками писал "рис"
\renewcommand{\tablename}{\textbf{Таблица}}		%Чтобы вместо table над таблицами писал Таблица

%%% Теоремы
\theoremstyle{plain} % Это стиль по умолчанию, его можно не переопределять.
\newtheorem{theorem}{Теорема}[section]
\newtheorem{proposition}[theorem]{Утверждение}

\theoremstyle{definition} % "Определение"
\newtheorem{definition}{Определение}[section]
\newtheorem{corollary}{Следствие}[theorem]
\newtheorem{problem}{Задача}[section]

\theoremstyle{remark} % "Примечание"
\newtheorem*{nonum}{Решение}
\newtheorem{zamech}{Замечание}[theorem]

%%% Правильные мат. символы для русского языка
\renewcommand{\epsilon}{\ensuremath{\varepsilon}}
\renewcommand{\phi}{\ensuremath{\varphi}}
\renewcommand{\kappa}{\ensuremath{\varkappa}}
\renewcommand{\le}{\ensuremath{\leqslant}}
\renewcommand{\leq}{\ensuremath{\leqslant}}
\renewcommand{\ge}{\ensuremath{\geqslant}}
\renewcommand{\geq}{\ensuremath{\geqslant}}
\renewcommand{\emptyset}{\varnothing}

%%% Для лекций по инфе
\usepackage{tikz}  
\usetikzlibrary{graphs}
\usepackage{alltt}
\newcounter{infa}[section]
\newcounter{num}
\definecolor{infa}{rgb}{0, 0.2, 0.89}
\definecolor{infa1}{rgb}{0, 0.3, 1}
\definecolor{grey}{rgb}{0.5, 0.5, 0.5}
\newcommand{\tab}{\ \ \ }
\newcommand{\com}[1]{{\color{grey}\# #1}}
\newcommand{\num}{\addtocounter{num}{1}\arabic{num}\tab}
\newcommand{\defi}{{\color{infa}def}}
\newcommand{\globali}{{\color{infa}global}}
\newcommand{\ini}{{\color{infa}in}}
\newcommand{\rangei}{{\color{infa}range}}
\newcommand{\fori}{{\color{infa}for}}
\newcommand{\ifi}{{\color{infa}if}}
\newcommand{\elsei}{{\color{infa}else}}
\newcommand{\printi}{{\color{infa1}print}}
\newcommand{\enumeratei}{{\color{infa1}enumerate}}
\newcommand{\maxi}{{\color{infa}max}}
\newcommand{\classi}{{\color{infa}class}}
\newcommand{\returni}{{\color{infa}return}}
\newcommand{\elifi}{{\color{infa}elif}}
\newcommand{\seti}{{\color{infa}set}}
\newcommand{\noti}{{\color{infa}not}}
\newcommand{\dicti}{{\color{infa}dict}}
\newcommand{\zipi}{{\color{infa}zip}}
\newcommand{\chri}{{\color{infa}chr}}
\newcommand{\ordi}{{\color{infa}ord}}
\newcommand{\leni}{{\color{infa}len}}
\newcommand{\deli}{{\color{infa}del}}
\newcommand{\sortedi}{{\color{infa}sorted}}
\newcommand{\keyi}{{\color{infa}key}}
\newcommand{\lambdai}{{\color{infa}lambda}}
\newcommand{\inti}{{\color{infa}int}}
\newcommand{\inputi}{{\color{infa}input}}
\newcommand{\isi}{{\color{infa}is}}
\newcommand{\Nonei}{{\color{infa}None}}
\newcommand{\whilei}{{\color{infa}while}}
\newcommand{\andi}{{\color{infa}and}}
\newcommand{\fromi}{{\color{infa}from}}
\newcommand{\importi}{{\color{infa}import}}
\newcommand{\continuei}{{\color{infa}continue}}
\newenvironment{infa}[1]{
	
	\vspace{0.5cm}
	\addtocounter{infa}{1}%
	\noindent{\large \textbf{Программа №\thesection.\arabic{infa}.}\ \textbf{#1}}%
	\begin{alltt}%
	}{\end{alltt}
	\setcounter{num}{0}
	\vspace{0.1cm}}
\newenvironment{infanoname}{
	
	%\vspace{0.5cm}
	%\addtocounter{infa}{1}%
	%\noindent{\large \textbf{Программа №\thesection.\arabic{infa}.}\ \textbf{#1}}%
	\begin{alltt}%
	}{\end{alltt}
	\setcounter{num}{0}
	\vspace{0.1cm}}

\usepackage{animate} % Для добавления гифок
\usepackage{xmpmulti}
%Пример кода:
%\begin{infa}{Поразрядная сортировка}
%	\ \num \defi count_sort(a):\tab \com{определяет нашу функцию}
%	\ \num \tab m = \maxi(a)+1
%	\ \num \tab q = [0]*m
%	\ \num \tab \fori x \ini a:
%	\ \num \tab \tab q[x] += 1
%	\ \num \tab pos = 0
%	\ \num \tab \fori x \ini q:
%	\ \num \tab \tab \fori i \ini \rangei(q[x]):
%	\ \num \tab \tab \tab a[pos] = x
%	\num \tab \tab \tab pos += 1
%\end{infa}

\usepackage[left=1.27cm,right=1.27cm,top=1.27cm,bottom=2cm]{geometry}
%\hbox to\textwidth{команда колонтитула}
\begin{document}
\newcounter{lec}
\newcommand{\lec}[1]{\addtocounter{lec}{1} \setcounter{section}{0}%
\begin{center}
{\LARGE ЛЕКЦИЯ \arabic{lec}%
\vspace{2mm}%

\textbf{#1}%
}
\end{center}
}
\newpage
\
\setcounter{lec}{18}
\lec{Обход графа в ширину (BFS)}
\section{Визуализация алгоритма BFS (пожар на графе)}
\begin{wrapfigure}{r}{0.4\linewidth}
\begin{frame}{Анимация BFS}
	\animategraphics[loop,controls,width=\linewidth]{1}{frame-}{0}{9}
\end{frame}
\caption{Белый — вершина, которая еще не обнаружена. Серый — вершина, уже обнаруженная и добавленная в очередь. Черный — вершина, извлечённая из очереди.}
\vspace{-0.7cm}
\end{wrapfigure}

Данный алгоритм можно сравнить с разгорающимся лесом (это отразилось на названии переменных в коде, см. ниже). Зажжем первую вершину (выбираем какую-то стартовую). От нее, как по мостикам, по ребрам графа огонь (наш алгоритм) переходит на соседние вершины. После этого сами соседние вершины уже зажигают своих соседей. При этом, чтобы наш алгоритм постоянно не записывал уже зажженные вершины, нам нужно, чтобы вершины «догорали» (необходимо убирать вершины, соседей которых уже проверили, из списка зажженных вершин). Т.е. этот алгоритм вкратце можно описать так:\\
1) Вершина графа загорается.\\
2) Передает огонь на все своих соседей.\\
3) Догорает.\\
И так происходит до того момента, пока мы не пройдем по всем соседям.


Более подробная визуализация изложена в \href{https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D1%88%D0%B8%D1%80%D0%B8%D0%BD%D1%83}{википедии}.

\textbf{Прагматический смысл обхода в ширину:} \textit{алгоритм позволяет находить расстояния на неориентированном графе от каждой вершины.}  При этом остовное дерево BFS имеет наименьший диаметр для данной точки A.



Применение алгоритма:
\begin{itemize}
	\item Построение остовного дерева
	\item Поиск расстояния (для не взвешенного графа)
	\item Обнаружение циклов наименьшей длины (когда происходит попытка зажечь вершину, которая уже горит, причем не ту, из которой позвали) 
	\item Подсчет компонент связности
\end{itemize}

\section{Реализация алгоритма BFS}
\begin{infa}{Реализация алгоритма BFS}
\ \num \defi bfs_fire(G, start, fired = \Nonei):
\ \num \tab \ifi fired \isi \Nonei:
\ \num \tab \tab fired = \seti()
\ \num \tab fired.add(start)
\ \num \tab time = \{start: 0\} \com{Хранение времен их добывания}
\ \num \tab Q = [start]
\ \num \tab \whilei Q:
\ \num \tab \tab current = Q.pop(0) \com{Для списка это не эффективно}
\ \num \tab \tab \fori neighbour \ini G[current]:
\num \tab \tab \tab \ifi neighbour \noti \ini fired:
\num \tab \tab \tab \tab fired.add(neighbour)
\num \tab \tab \tab \tab Q.append(neighbour)
\num \tab \tab \tab \tab \printi(current, neighbour) \com{Для построения остовного дерева}
\num \tab \tab \tab \tab time[neighbour] = time[current] + 1
\end{infa}
Построчный комментарий кода:\\
2) Задаём \texttt{fired} как пустое множество (по умолчанию этого делать нельзя, т.к. тогда это станет глобальной переменной).\\
4) Добавляем стартовую вершину в «догоревшие».\\
5) Хранение времени, за которое мы доходим до вершины (это позволяет находить расстояние до вершины от стартовой).\\
6) Добавление вершины в очередь «горящих».\\
7) Цикл работает, пока есть хотя одна горящая вершина.\\
8) Берем первую вершины из очереди.\\
9) Проходим по всем соседям вершины.\\
11) Добавляем нашу вершину в очередь «зажженных».\\
12) Добавляем в «догоревших» (чтобы снова не записывать его в очередь «зажженных»).\\
13) Это позволяет получить остовное дерево.\\
14) Так и получаем расстояние до вершины.\\


\section{Алгоритм Дейкстры}
Данный алгоритм необходим для поиска кратчайшего маршрута от исходной вершины до всех вершин графа. Его метод работы основан на обходе графа в ширину (как мы помним, данный алгоритм позволяет находить расстояния в невзвешенном графе). Идея аналогичная --- «зажигаем» вершины, после этого проходим по соседям «зажженной» вершины. Но теперь в нашем проходе появляется определенный порядок --- вначале мы идем к вершинам, путь к которым наиболее краток. Это позволяет раньше добавить вершины в список «сгоревших» и закончить вычислять длину маршрута к ним.

Подробная визуализация алгоритма изложена в \href{https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%94%D0%B5%D0%B9%D0%BA%D1%81%D1%82%D1%80%D1%8B#.D0.9D.D0.B5.D1.84.D0.BE.D1.80.D0.BC.D0.B0.D0.BB.D1.8C.D0.BD.D0.BE.D0.B5_.D0.BE.D0.B1.D1.8A.D1.8F.D1.81.D0.BD.D0.B5.D0.BD.D0.B8.D0.B5}{википедии}.

\textbf{Условие на граф: не должно быть ребер с отрицательным весом.}

\section{Реализация алгоритма Дейкстры}
\begin{infa}{Реализация алгоритма Дейкстры (не эффективен)}
\ \num \defi dijkstra(G, start): \com{G - словарь словарей с весами}
\ \num \tab d = \{v: float('+inf') \fori v \ini G\}
\ \num \tab d[start] = 0
\ \num \tab used = \seti()
\ \num \tab \whilei \leni(used) != \leni(G):
\ \num \tab \tab min_d = float('+inf')
\ \num \tab \tab \fori v \ini d:
\ \num \tab \tab \tab \ifi d[v] < min_d \andi v \noti \ini used:
\ \num \tab \tab \tab \tab current = v
\num \tab \tab \tab \tab min_d = d[v]
\num \tab \tab \fori neighbour \ini G[current]:
\num \tab \tab \tab l = d[current] + G[current][neighbour]
\num \tab \tab \tab \ifi l < d[neighbour]:
\num \tab \tab \tab \tab d[neighbour] = l
\num \tab \tab used.add(current)
\num \tab \returni d \com{Алгоритм не эффективен}
\end{infa}
Построчный комментарий кода:\\
1) G --- словарь словарей (каждой вершине соответствует список вершин, каждой из которых поставили в соответствие длину ребра).\\
2) Задаем изначальный словарь длин расстояний до вершин.\\
3) Задаем длину расстояния до исходной вершины (она ноль, очевидно).\\
4) Задаем множество пройденных вершин.\\
5) Пока не все вершины использованы.\\
6) Задаем расстояние (делаем его бесконечным, чтобы потом можно было найти минимальное).\\
7-10) Находим вершину с минимальным путем до нее. При первом проходе это будет начальная вершина (до нее путь ноль). При втором проходе она уже будет смотреть и выбирать из соседей исходной вершины и т.д.\\
11-14) Пробегаемся по соседям нашей вершины и рассчитываем путь до нее. Если он меньше того пути, который сейчас соответствует этой вершине, то мы записываем новое значение --- это путь до той вершины, по соседям которой мы пробегаемся плюс путь от нее до соседа.\\
15) Добавляем проверенную вершину в использованное.\\

\begin{infa}{Реализация алгоритма Дейкстры}
	\ \num \fromi heapq \importi*
	\ \num \defi dijkstra(G, start): \com{G - словарь словарей с весами}
	\ \num \tab d = \{v: float('+inf') \fori v \ini G\}
	\ \num \tab d[start] = 0
	\ \num \tab Q = [(0, start)]
	\ \num \tab used = \seti()
	\ \num \tab \whilei \leni(used) != \leni(G):
	\ \num \tab \tab d_c, current = heappop(Q)
	\ \num \tab \tab \ifi d_c != d[current]:
	\num \tab \tab \tab \continuei
	\num \tab \tab \fori neighbour \ini G[current]:
	\num \tab \tab \tab l = d[current] + G[current][neighbour]
	\num \tab \tab \tab \ifi l < d[neighbour]:
	\num \tab \tab \tab \tab d[neighbour] = l
	\num \tab \tab \tab \tab heappush(Q, (l, neighbour))
	\num \tab \tab used.add(current)
	\num \tab \returni d
	\label{dijkstra_heapq}
\end{infa}
Данная программа имеет такую же схему работы, как и предыдущая, но для большей эффективности использована пирамида кортежей.































%\begin{infa}{}
%\num def graph_input():
%\num \tab N = \inti(\inputi())
%\num \tab G = ()
%\num \tab M = \inti(\inputi())
%\num \tab \fori i \ini \rangei(M):
%\num \tab \tab a, b = \inputi().split()
%\num \tab \tab \ifi a \ini G:
%\num \tab \tab \tab G[a].add(b)
%\num \tab \tab \elsei:
%\num \tab \tab \tab G[a] = (b)
%\end{infa}



























\begin{center}
	\vfill \emph{{\small Г. С. Демьянов, \href{https://vk.com/id37346992}{VK}\\
С. С. Клявинек, \href{https://vk.com/id85132547}{VK}
}}
\end{center}






\end{document} 